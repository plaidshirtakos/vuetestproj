const fs = require ('fs-extra');
const path = require ('upath');

let plugins = [];
let latestTarget = '';

module.exports.loadPlugins = (target) =>
{
	function loadPluginsFolder (folder) {
		let localFolder = path.join (__dirname,'source/plugins', folder);
		let allPlugins = fs.readdirSync(localFolder).filter (file => file !== '.' && file !== '..' && fs.statSync (path.join (localFolder, file)).isDirectory());

		let provided = {};

		for(let plugin of allPlugins)
		{
			let file_package_json = path.join (localFolder, plugin, 'package.json');
			if (fs.existsSync (file_package_json))
			{
				let package_json = require(file_package_json);
				if (package_json.name !== plugin)
				{
					console.log ('  plugin '+path.join (folder, plugin)+' has wrong name, rename to '+plugin);
					package_json.name = plugin;
				}
				if (package_json.plugin[target] !== undefined)
				{
					if (!package_json.plugin[target].disabled)
					{
						plugins.push ({
							folder: folder,
							name: package_json.name,
							id: path.join (folder, package_json.name),
							main: package_json.plugin[target].main,
							consumes: package_json.plugin[target].consumes,
							provides: package_json.plugin[target].provides
						});
						for (let provide of package_json.plugin[target].provides)
						{
							if (!provided[provide])
							{
								provided[provide] = {
									folder: path.join (folder, package_json.name),
									id: path.join (folder, package_json.name),
									main: package_json.plugin[target].main
								};
							}
							else
							{
								console.error ('WARN '+provide+' is already provided by plugin '+provided[provide].id);
							}
						}
					}
				}
			}
			else
			{
				loadPluginsFolder (path.join (folder, plugin));
			}
		}
		for (let plugin of plugins)
		{
			let types = '/** This file is automatically generated by webpack plugins, no not edit\n *\n';
			types = types + ' * In '+plugin.main+', import this file\n * import { Imports, RegisterFunction } from "./'+target+'_types";\n */\n\n';
			for (let consume of plugin.consumes)
			{
				if (provided[consume])
				{
					types = types + 'import { '+consume+' } from "'+path.relative (path.join (plugin.folder, plugin.name, path.dirname (plugin.main)), path.join (provided[consume].folder, path.dirname (provided[consume].main)))+'/'+target+'_exports";\n';
					types = types + 'export * from "'+path.relative (path.join (plugin.folder, plugin.name, path.dirname (plugin.main)), path.join (provided[consume].folder, path.dirname(provided[consume].main)))+'/'+target+'_exports";\n';
				}
				else
				{
					console.error ('WARN '+consume+' is not provided by any plugin');
				}
			}
			for (let provide of plugin.provides)
			{
				types = types + 'import { '+provide+' } from "./'+target+'_exports";\nexport * from "./'+target+'_exports";\n';
			}

			types = types + '\nexport interface Imports\n{\n';
			for (let consume of plugin.consumes)
			{
				if (provided[consume])
				{
					types = types + '\t'+consume+': '+consume+';\n';
				}
			}
			types = types + '}\n\n';
			types = types + '\nexport interface Exports\n{\n';
			for (let provide of plugin.provides)
			{
				types = types + '\t'+provide+': '+provide+';\n';
			}
			types = types + '}\n\n';
			types = types + 'export type RegisterFunction = (error: null | Error, provides: Exports) => void;\n';

			if (target === "ui")
			{
				types = types + '\ndeclare global\n{\n\texport interface UI\n\t{\n';
				for (let provide of plugin.provides)
				{
					types = types + '\t\t'+provide+': '+provide+';\n';
				}
				types = types + '\t}\n}\n\n';
			}

			// add vue type augmentation
			// if (target === 'ui')
			// {
			// 	types = types + 'import Vue from "vue";\n';
			// 	types = types + 'declare module "vue/types/vue" {\n\tinterface Vue {\n\t\tui: Imports\n\t}\n}\t';
			// }

			fs.writeFileSync (path.join (path.dirname (path.join (__dirname, 'source/plugins', plugin.folder, plugin.name, plugin.main)), target+'_types.ts'), types);

			// TODO parse exports file
			let exportsFilename = path.join (path.dirname (path.join (__dirname, 'source/plugins', plugin.folder, plugin.name, plugin.main)), target+'_exports.ts');
			if (!fs.existsSync (exportsFilename))
			{
				let types = '/** This file is used to import the data types that this plugin provides */\n\n';
				for (let provide of plugin.provides)
				{
					types = types + 'export interface '+provide+'\n{\n\t // functions that your plugin exports\n}\n\n';
				}
				fs.writeFileSync (exportsFilename, types);
			}
		}
	}

	if (target !== latestTarget)
	{
		latestTarget = target;
		plugins = [];
		loadPluginsFolder ('');
	}

	return plugins;
};